% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/EVPPI.R
\name{evppi}
\alias{evppi}
\title{evppi}
\usage{
evppi(
  D,
  U,
  Theta_int,
  Theta_rem,
  method = "NP",
  J = 10000,
  K = 10000,
  cond_fun = NULL,
  model = NULL
)
}
\arguments{
\item{D}{Number of decision options}

\item{U}{Utility function that depends on the decision option and parameters}

\item{Theta_int}{Named matrix of parameter draws from prior/posterior distribution for parameters of interest}

\item{Theta_rem}{Named matrix of parameter draws from prior/posterior distribution for the remaining parameters (not of interest)}

\item{method}{Approximation method. Either MC for Monte-Carlo or NP for non-parametric (default)}

\item{J}{Number of inner Monte Carlo loops. Only required for the Monte Carlo approximation method.}

\item{K}{Number of outer Monte Carlo loops. Only required for the Monte Carlo approximation method.}

\item{cond_fun}{A function that generates sets of Theta_rem conditional on the current values of Theta_int. The first argument must be J and the second must be a parameter vector. Only required for the Monte Carlo approximation method.}

\item{model}{Generalised additive regression model specification (formula). Only required for the non-parametric approximation method.}
}
\value{
Expected value of partial perfect information. If using the non-parametric method, a list will be returned containing the expected value of partial perfect information in addition to the partial incremental net benefit.
}
\description{
Computes the expected value of partial perfect information using either a Monte-Carlo or non-parametric approximation method
}
\examples{
# two parameters (one parameter of interest), two decision options
D <- 2
U <- function(d, Theta_int, Theta_rem) (d == 1)*Theta_int +
                                       (d == 2)*Theta_rem
N <- 10000
Theta_int <- matrix(rbeta(N, 2, 3), nrow = N, ncol = 1, dimnames = list(NULL, "theta_A"))
Theta_rem <- matrix(rbeta(N, 2, 3), nrow = N, ncol = 1, dimnames = list(NULL, "theta_B"))
cond_fun <- function(J, Theta_int) rbeta(J, 2, 3)
evppi(D, U, Theta_int, Theta_rem, method = "MC", cond_fun = cond_fun)
evppi(D, U, Theta_int, Theta_rem, method = "NP", model = "s(theta_A)")

# three parameters (two parameters of interest), three decision options
D <- 3
U <- function(d, Theta_int, Theta_rem) (d == 1)*Theta_int[,"theta_A"] +
                                       (d == 2)*Theta_int[,"theta_B"] +
                                       (d == 3)*Theta_rem
N <- 10000
Theta_int <- Theta[,c("theta_A", "theta_B")]
Theta_rem <- matrix(Theta[,"theta_C"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_C"))
cond_fun <- function(J, Theta_int) rbeta(J, 2, 3)
evppi(D, U, Theta_int, Theta_rem, method = "MC", cond_fun = cond_fun)
evppi(D, U, Theta_int, Theta_rem, method = "NP", model = "te(theta_A, theta_B)")
}
