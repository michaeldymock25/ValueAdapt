
#' @title evsi
#' @description Computes the expected value of sample information using either a Monte-Carlo, non-parametric or moment matching approximation method
#' @import EVSI
#' @import mgcv
#' @import RhpcBLASctl
#' @import stats
#' @param D Number of decision options
#' @param U Utility function that depends on the decision option and parameters
#' @param Theta Named matrix of parameter draws from prior/posterior distribution
#' @param method Approximation method. Either MC for Monte-Carlo, NP for non-parametric (default) or MM for moment matching. The moment matching method requires the evppi function to be run in advance using the non-parametric method to generate INB_partial.
#' @param J Number of inner Monte Carlo loops. Only required for the Monte Carlo approximation method.
#' @param K Number of outer Monte Carlo loops. Only required for the Monte Carlo approximation method.
#' @param samp_fun A function that generates a sample of data based on the parameter draws (posterior predictive draw). The only argument is the matrix of parameter draws Theta. Returns a matrix of data.
#' @param post_fun A function that generates draws from the posterior distribution given the previous distribution and a sample of data generated by the samp_fun function. The first argument must be the number of draws to generate and the second argument must be the sample of data generated by the samp_fun function. Only required for the Monte Carlo and moment matching approximation methods.
#' @param stat_fun A function to generate a low-dimensional summary statistic based on the sample of data generated by the samp_fun function. The only argument is a vector of sampled data. Only required for the non-parametric approximation method.
#' @param model Generalised additive regression model specification (formula). Only required for the non-parametric approximation method.
#' @param INB_partial Samples of INB for the parameters of interest generated from the evppi function using the non-parametric approximation method. Only required for the moment matching approximation method.
#' @param L Number of model reruns to estimate the expected variance of the posterior net benefit. Only required for the moment matching approximation method.
#' @return Expected value of sample information
#' @examples
#' # one parameter, two decision options
#' D <- 2
#' U <- function(d, Theta) (-1)^(d-1)*(Theta - 0.4)
#' N <- 10000
#' Theta <- matrix(rbeta(N, 2, 3), nrow = N, ncol = 1, dimnames = list(NULL, "theta"))
#' samp_fun <- function(Theta) matrix(rbinom(nrow(Theta), size = 10, prob = Theta),
#'                                    nrow = nrow(Theta), ncol = 1, dimnames = list(NULL, "theta"))
#' post_fun <- function(J, x) rbeta(J, 2 + x, 3 + 10 - x)
#' stat_fun <- function(x) x/10
#' evsi(D, U, Theta, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' evsi(D, U, Theta, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun, model = "s(theta)")
#'
#' # two parameters (one parameter of interest), two decision options
#' D <- 2
#' U <- function(d, Theta) Theta[,d]
#' N <- 10000
#' Theta <- matrix(c(rbeta(N, 2, 3), rbeta(N, 2, 3)),
#'                 nrow = N, ncol = 2, dimnames = list(NULL, c("theta_A", "theta_B")))
#' samp_fun <- function(Theta) matrix(rbinom(nrow(Theta), size = 10, prob = Theta[,"theta_A"]),
#'                                    nrow = nrow(Theta), ncol = 1, dimnames = list(NULL, "theta_A"))
#' post_fun <- function(J, x) matrix(c(rbeta(J, 2 + x, 3 + 10 - x), rbeta(J, 2, 3)),
#'                                   nrow = J, ncol = 2,
#'                                   dimnames = list(NULL, c("theta_A", "theta_B")))
#' stat_fun <- function(x) x/10
#' evsi(D, U, Theta, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' evsi(D, U, Theta, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun, model = "s(theta_A)")
#' U_evppi <- function(d, Theta_int, Theta_rem) (d == 1)*Theta_int + (d == 2)*Theta_rem
#' Theta_int <- matrix(Theta[,"theta_A"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_A"))
#' Theta_rem <- matrix(Theta[,"theta_B"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_B"))
#' out <- evppi(D, U_evppi, Theta_int, Theta_rem, method = "NP", model = "s(theta_A)")
#' evsi(D, U, Theta, method = "MM", samp_fun = samp_fun, post_fun = post_fun,
#'      INB_partial = out$INB_partial)
#'
#' # three parameters (two parameters of interest), three decision options
#' D <- 3
#' U <- function(d, Theta) Theta[,d]
#' N <- 10000
#' Theta <- matrix(c(rbeta(N, 2, 3), rbeta(N, 2, 3), rbeta(N, 2, 3)),
#'                 nrow = N, ncol = 3, dimnames = list(NULL, c("theta_A", "theta_B", "theta_C")))
#' samp_fun <- function(Theta) apply(Theta[,c("theta_A", "theta_B")], 2,
#'                                   function(theta) rbinom(length(theta), size = 10, prob = theta))
#' post_fun <- function(J, x) matrix(c(rbeta(J, 2 + x["theta_A"], 3 + 10 - x["theta_A"]),
#'                                     rbeta(J, 2 + x["theta_B"], 3 + 10 - x["theta_B"]),
#'                                     rbeta(J, 2, 3)),
#'                                   nrow = J, ncol = 3,
#'                                   dimnames = list(NULL, c("theta_A", "theta_B", "theta_C")))
#' stat_fun <- function(x) x/10
#' evsi(D, U, Theta, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' evsi(D, U, Theta, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun,
#'      model = "te(theta_A, theta_B)")
#' U_evppi <- function(d, Theta_int, Theta_rem, Omega) (d == 1)*Theta_int[,"theta_A"] +
#'                                                     (d == 2)*Theta_int[,"theta_B"] +
#'                                                     (d == 3)*Theta_rem
#' Theta_int <- Theta[,c("theta_A", "theta_B")]
#' Theta_rem <- matrix(Theta[,"theta_C"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_C"))
#' cond_fun <- function(J, Theta_int) rbeta(J, 2, 3)
#' out <- evppi(D, U_evppi, Theta_int, Theta_rem, method = "NP", cond_fun = cond_fun,
#'              model = "te(theta_A, theta_B)")
#' evsi(D, U, Theta, method = "MM", samp_fun = samp_fun, post_fun = post_fun,
#'      INB_partial = out$INB_partial)
#' @rdname evsi
#' @export
evsi <- function(D, U, Theta, method = "NP", J = 10000, K = 10000, samp_fun = NULL, post_fun = NULL,
                 stat_fun = NULL, model = NULL, INB_partial = NULL, L = 50){

  if(!(method %in% c("MC", "NP", "MM"))) stop("Method must be specified as MC, NP or MM")
  N <- nrow(Theta)

  ## compute incremental net benefit using utility function U for each decision option d

  NB <- sapply(1:D, function(d) U(d, Theta))
  INB <- NB - NB[,1]

  ## estimate the expected value of sample information

  if(method == "MC"){
    if(N < K) stop("The number of parameter draws must be greater than or equal to K")
    Theta_redraw <- as.matrix(Theta[sample.int(N, size = K),])
    samp_out <- samp_fun(Theta_redraw)
    SI <- sapply(1:K, function(k){
      Theta_tmp <- post_fun(J, samp_out[k,])
      NB_tmp <- sapply(1:D, function(d) U(d, Theta_tmp))
      INB_tmp <- NB_tmp - NB_tmp[,1]
      max(colMeans(INB_tmp))
    })
    EVSI <- mean(SI) - max(colMeans(INB))
  } else if(method == "NP"){
    samp_out <- samp_fun(Theta)
    summ_stats <- t(matrix(apply(samp_out, 1, stat_fun), ncol = N))
    colnames(summ_stats) <- colnames(samp_out)
    g_hat <- vector("list", D)
    g_hat[[1]] <- rep(0, N)
    RhpcBLASctl::blas_set_num_threads(1)
    for(d in 2:D) g_hat[[d]] <- gam(update(formula(INB[, d] ~ .), formula(paste(".~", model))), data = as.data.frame(summ_stats))$fitted
    EVSI <- mean(do.call(pmax, g_hat)) - max(unlist(lapply(g_hat, mean)))
  } else if(method == "MM"){
    Theta_redraw <- gen.quantiles(parameter = colnames(Theta), param.mat = Theta, Q = L)
    samp_out <- samp_fun(as.matrix(Theta_redraw))
    var_est <- lapply(1:L, function(l){
      Theta_tmp <- post_fun(N, samp_out[l,])
      NB_tmp <- sapply(1:D, function(d) U(d, Theta_tmp))
      INB_tmp <- NB_tmp - NB_tmp[,1]
      var(INB_tmp[,-1])
    })
    prior_var <- var(as.matrix(INB[,-1]))
    mu_mn <- colMeans(as.matrix(INB[,-1]))
    mu_var <- prior_var - Reduce("+", var_est)/L
    if(D <= 2){
      INB_rescaled <- as.matrix((INB_partial[,-1] - mu_mn) * 1/sd(INB_partial[,-1]) * as.numeric(sqrt(mu_var)) + mu_mn)
    } else {
      mu_var_eigen <- eigen(mu_var)
      mu_var_sqrt <- mu_var_eigen$vectors %*% diag(sqrt(mu_var_eigen$values)) %*% t(mu_var_eigen$vectors)
      prior_var_eigen <- eigen(prior_var)
      prior_var_sqrt_inv <- chol2inv(chol(prior_var_eigen$vectors %*% diag(sqrt(prior_var_eigen$values)) %*% t(prior_var_eigen$vectors)))

      INB_rescaled <- t(t(t(t(INB_partial[,-1]) - mu_mn) %*% prior_var_sqrt_inv %*% mu_var_sqrt) + mu_mn)
    }
    EVSI <- mean(apply(INB_rescaled, 1, function(x) max(0, x))) - max(colMeans(INB))
  }

  return(EVSI)
}