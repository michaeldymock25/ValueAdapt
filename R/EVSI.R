
#' @title evsi
#' @description Computes the expected value of sample information using either a Monte-Carlo, non-parametric or moment matching approximation method
#' @import EVSI
#' @import mgcv
#' @import RhpcBLASctl
#' @import stats
#' @param D Number of decision options
#' @param U Utility function that depends on the decision option and parameters
#' @param Theta Named matrix of parameter draws from prior/posterior distribution
#' @param method Approximation method. Either MC for Monte-Carlo, NP for non-parametric (default) or MM for moment matching. The moment matching method requires the evppi function to be run in advance using the non-parametric method to generate INB_partial.
#' @param K Number of outer Monte Carlo loops. Only required for the Monte Carlo approximation method.
#' @param samp_args List of arguments to be passed to samp_fun(). Defaults to an empty list.
#' @param samp_fun A function that generates a sample of data based on the parameter draws (posterior predictive draw). The only argument should be a list including parameter draws from Theta and any additional parameters. Returns a vector of data to be passed to post_fun().
#' @param post_args List of arguments to be passed to post_fun(). Defaults to an empty list.
#' @param post_fun A function that generates draws from the posterior distribution given the previous distribution and a sample of data generated by the samp_fun function. The only argument should be a list including a sample of data from samp_fun(), number of draws required from the posterior distribution (N) and any additional parameters. Only required for the Monte Carlo and moment matching approximation methods.
#' @param stat_fun A function to generate a low-dimensional summary statistic based on the sample of data generated by the samp_fun function. The only argument is a vector of sampled data. Only required for the non-parametric approximation method.
#' @param model Generalised additive regression model specification (formula). Only required for the non-parametric approximation method. Should be a function of the data exported by samp_fun().
#' @param INB_partial Samples of INB for the parameters of interest generated from the evppi function using the non-parametric approximation method. Only required for the moment matching approximation method.
#' @param Q Number of model reruns to estimate the expected variance of the posterior net benefit. Only required for the moment matching approximation method.
#' @return Expected value of sample information
#' @examples
#' # one parameter, two decision options
#' D <- 2
#' U <- function(d, Theta) (-1)^(d-1)*(Theta - 0.4)
#' N <- 10000
#' Theta <- matrix(rbeta(N, 2, 3), nrow = N, ncol = 1, dimnames = list(NULL, "theta"))
#' samp_fun <- function(args) c(x = rbinom(1, size = 10, prob = args$theta))
#' post_fun <- function(args) rbeta(args$N, 2 + args$x, 3 + 10 - args$x)
#' stat_fun <- function(x) x/10
#' evsi(D, U, Theta, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' evsi(D, U, Theta, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun, model = "s(x)")
#'
#' # two parameters (one parameter of interest), two decision options
#' D <- 2
#' U <- function(d, Theta) Theta[,d]
#' N <- 10000
#' Theta <- matrix(c(rbeta(N, 2, 3), rbeta(N, 2, 3)),
#'                 nrow = N, ncol = 2, dimnames = list(NULL, c("theta_A", "theta_B")))
#' samp_fun <- function(args) c(x = rbinom(1, size = 10, prob = args$theta_A))
#' post_fun <- function(args) matrix(c(rbeta(args$N, 2 + args$x, 3 + 10 - args$x),
#'                                     rbeta(args$N, 2, 3)),
#'                                   nrow = args$N, ncol = 2,
#'                                   dimnames = list(NULL, c("theta_A", "theta_B")))
#' stat_fun <- function(x) x/10
#' evsi(D, U, Theta, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' evsi(D, U, Theta, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun, model = "s(x)")
#' U_evppi <- function(d, Theta_int, Theta_rem) (d == 1)*Theta_int + (d == 2)*Theta_rem
#' Theta_int <- matrix(Theta[,"theta_A"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_A"))
#' Theta_rem <- matrix(Theta[,"theta_B"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_B"))
#' out <- evppi(D, U_evppi, Theta_int, Theta_rem, method = "NP", model = "s(theta_A)")
#' evsi(D, U, Theta, method = "MM", samp_fun = samp_fun, post_fun = post_fun,
#'      INB_partial = out$INB_partial)
#'
#' # three parameters (two parameters of interest), three decision options
#' D <- 3
#' U <- function(d, Theta) Theta[,d]
#' N <- 10000
#' Theta <- matrix(c(rbeta(N, 2, 3), rbeta(N, 2, 3), rbeta(N, 2, 3)),
#'                 nrow = N, ncol = 3, dimnames = list(NULL, c("theta_A", "theta_B", "theta_C")))
#' samp_fun <- function(args) c(x_A = rbinom(1, size = 10, prob = args$theta_A),
#'                              x_B = rbinom(1, size = 10, prob = args$theta_B))
#' post_fun <- function(args) matrix(c(rbeta(args$N, 2 + args$x_A, 3 + 10 - args$x_A),
#'                                     rbeta(args$N, 2 + args$x_B, 3 + 10 - args$x_B),
#'                                     rbeta(args$N, 2, 3)),
#'                                   nrow = args$N, ncol = 3,
#'                                   dimnames = list(NULL, c("theta_A", "theta_B", "theta_C")))
#' stat_fun <- function(x) x/10
#' evsi(D, U, Theta, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' evsi(D, U, Theta, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun,
#'      model = "te(x_A, x_B)")
#' U_evppi <- function(d, Theta_int, Theta_rem) (d == 1)*Theta_int[,"theta_A"] +
#'                                              (d == 2)*Theta_int[,"theta_B"] +
#'                                              (d == 3)*Theta_rem
#' Theta_int <- Theta[,c("theta_A", "theta_B")]
#' Theta_rem <- matrix(Theta[,"theta_C"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_C"))
#' out <- evppi(D, U_evppi, Theta_int, Theta_rem, method = "NP", model = "te(theta_A, theta_B)")
#' evsi(D, U, Theta, method = "MM", samp_fun = samp_fun, post_fun = post_fun,
#'      INB_partial = out$INB_partial)
#' @rdname evsi
#' @export
evsi <- function(D, U, Theta, method = "NP", K = 10000,
                 samp_args = list(), samp_fun = NULL, post_args = list(), post_fun = NULL,
                 stat_fun = NULL, model = NULL, INB_partial = NULL, Q = 50){

  if(!(method %in% c("MC", "NP", "MM"))) stop("Method must be specified as MC, NP or MM")

  ## compute incremental net benefit using utility function U for each decision option d

  NB <- sapply(1:D, function(d) U(d, Theta))
  INB <- NB - NB[,1]

  ## estimate the expected value of sample information

  N <- nrow(Theta)
  if(method == "MC"){
    if(N < K) stop("The number of parameter draws must be greater than or equal to K")
    Theta_redraw <- as.matrix(Theta[sample.int(N, size = K),])
    colnames(Theta_redraw) <- colnames(Theta)
    samp_out <- lapply(1:K, function(k){
                   samp_args_tmp <- c(samp_args, Theta_redraw[k,])
                   samp_fun(samp_args_tmp)
    })
    Theta_tmp <- lapply(1:K, function(k){
                    post_args_tmp <- c(post_args, D = D, N = N, samp_out[[k]])
                    post_fun(post_args_tmp)
    })
    SI <- sapply(1:K, function(k){
      NB_tmp <- sapply(1:D, function(d) U(d, Theta_tmp[[k]]))
      INB_tmp <- NB_tmp - NB_tmp[,1]
      max(colMeans(INB_tmp))
    })
    EVSI <- mean(SI) - max(colMeans(INB))
  } else if(method == "NP"){
    samp_out <- lapply(1:N, function(n){
                   Theta_tmp <- Theta[n,]
                   names(Theta_tmp) <- colnames(Theta)
                   samp_args_tmp <- c(samp_args, Theta_tmp)
                   samp_fun(samp_args_tmp)
    })
    summ_stats <- t(matrix(sapply(samp_out, stat_fun), ncol = N))
    colnames(summ_stats) <- names(samp_out[[1]])
    g_hat <- matrix(data = NA, nrow = N, ncol = D)
    g_hat[,1] <- 0
    RhpcBLASctl::blas_set_num_threads(1)
    for(d in 2:D) g_hat[,d] <- gam(update(formula(INB[, d] ~ .), formula(paste(".~", model))), data = as.data.frame(summ_stats))$fitted
    EVSI <- mean(apply(g_hat, 1, max)) - max(colMeans(g_hat))
  } else if(method == "MM"){
    Theta_redraw <- as.matrix(gen.quantiles(parameter = colnames(Theta), param.mat = Theta, Q = Q))
    samp_out <- lapply(1:Q, function(q){
      samp_args_tmp <- c(samp_args, Theta_redraw[q,])
      samp_fun(samp_args_tmp)
    })
    Theta_tmp <- lapply(1:Q, function(q){
      post_args_tmp <- c(post_args, D = D, N = N, samp_out[[q]])
      post_fun(post_args_tmp)
    })
    var_est <- lapply(1:Q, function(q){
      NB_tmp <- sapply(1:D, function(d) U(d, Theta_tmp[[q]]))
      INB_tmp <- NB_tmp - NB_tmp[,1]
      var(INB_tmp[,-1])
    })
    prior_var <- var(as.matrix(INB[,-1]))
    mu_mn <- colMeans(as.matrix(INB[,-1]))
    mu_var <- prior_var - Reduce("+", var_est)/Q
    if(D <= 2){
      INB_rescaled <- as.matrix((INB_partial[,-1] - mu_mn) * 1/sd(INB_partial[,-1]) * as.numeric(sqrt(mu_var)) + mu_mn)
    } else {
      mu_var_eigen <- eigen(mu_var)
      mu_var_sqrt <- mu_var_eigen$vectors %*% diag(sqrt(mu_var_eigen$values)) %*% t(mu_var_eigen$vectors)
      prior_var_eigen <- eigen(prior_var)
      prior_var_sqrt_inv <- chol2inv(chol(prior_var_eigen$vectors %*% diag(sqrt(prior_var_eigen$values)) %*% t(prior_var_eigen$vectors)))

      INB_rescaled <- t(t(t(t(INB_partial[,-1]) - mu_mn) %*% prior_var_sqrt_inv %*% mu_var_sqrt) + mu_mn)
    }
    EVSI <- mean(apply(INB_rescaled, 1, function(x) max(0, x))) - max(colMeans(INB))
  }

  return(EVSI)
}