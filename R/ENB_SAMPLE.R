
#' @title enb_sample
#' @description Computes the expected net benefit of collecting sample information using either a Monte-Carlo, non-parametric or moment matching approximation method
#' @import EVSI
#' @import mgcv
#' @import RhpcBLASctl
#' @import stats
#' @param D Number of decision options
#' @param U Utility function that depends on the decision option, parameters and decision times t_1 and t_2
#' @param Theta Named matrix of parameter draws from prior/posterior distribution
#' @param t Named vector of ascending decision times in years including the current time ("C"), analysis time ("A") and the time horizon ("H")
#' @param prop Vector containing current proportions of intervention use. Must sum to one.
#' @param cost Cost of sampling
#' @param method Approximation method. Either MC for Monte-Carlo, NP for non-parametric (default) or MM for moment matching. The moment matching method requires the evppi function to be run in advance using the non-parametric method to generate INB_partial.
#' @param J Number of inner Monte Carlo loops. Only required for the Monte Carlo approximation method.
#' @param K Number of outer Monte Carlo loops. Only required for the Monte Carlo approximation method.
#' @param samp_fun A function that generates a sample of data based on the parameter draws (posterior predictive draw). The only argument is the matrix of parameter draws Theta. Returns a matrix of data.
#' @param post_fun A function that generates draws from the posterior distribution given the previous distribution and a sample of data generated by the samp_fun function. The first argument must be the number of draws to generate and the second argument must be the sample of data generated by the samp_fun function. Only required for the Monte Carlo and moment matching approximation methods.
#' @param stat_fun A function to generate a low-dimensional summary statistic based on the sample of data generated by the samp_fun function. The only argument is a vector of sampled data. Only required for the non-parametric approximation method.
#' @param model Generalised additive regression model specification (formula). Only required for the non-parametric approximation method.
#' @param INB_partial Samples of INB for the parameters of interest generated from the evppi function using the non-parametric approximation method. Only required for the moment matching approximation method.
#' @param Q Number of model reruns to estimate the expected variance of the posterior net benefit. Only required for the moment matching approximation method.
#' @return Expected net benefit of collecting sample information
#' @examples
#' # one parameter, two decision options
#' D <- 2
#' U <- function(d, Theta, t_1, t_2) sum(1.05^(1-(t_1:t_2)))*(-1)^(d-1)*(Theta - 0.4)
#' N <- 10000
#' Theta <- matrix(rbeta(N, 2, 3), nrow = N, ncol = 1, dimnames = list(NULL, "theta"))
#' t <- c(C = 0, A = 1, H = 15)
#' prop <- rep(1/D, D)
#' cost <- 0
#' samp_fun <- function(Theta) matrix(rbinom(nrow(Theta), size = 10, prob = Theta),
#'                                    nrow = nrow(Theta), ncol = 1, dimnames = list(NULL, "theta"))
#' post_fun <- function(J, x) rbeta(J, 2 + x, 3 + 10 - x)
#' stat_fun <- function(x) x/10
#' enb_sample(D, U, Theta, t, prop, cost, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' enb_sample(D, U, Theta, t, prop, cost, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun,
#'            model = "s(theta)")
#'
#' # two parameters (one parameter of interest), two decision options
#' D <- 2
#' U <- function(d, Theta, t_1, t_2) sum(1.05^(1-(t_1:t_2)))*Theta[,d]
#' N <- 10000
#' Theta <- matrix(c(rbeta(N, 2, 3), rbeta(N, 2, 3)),
#'                 nrow = N, ncol = 2, dimnames = list(NULL, c("theta_A", "theta_B")))
#' t <- c(C = 0, A = 1, H = 15)
#' prop <- rep(1/D, D)
#' cost <- 0
#' samp_fun <- function(Theta) matrix(rbinom(nrow(Theta), size = 10, prob = Theta[,"theta_A"]),
#'                                    nrow = nrow(Theta), ncol = 1, dimnames = list(NULL, "theta_A"))
#' post_fun <- function(J, x) matrix(c(rbeta(J, 2 + x, 3 + 10 - x), rbeta(J, 2, 3)),
#'                                   nrow = J, ncol = 2,
#'                                   dimnames = list(NULL, c("theta_A", "theta_B")))
#' stat_fun <- function(x) x/10
#' enb_sample(D, U, Theta, t, prop, cost, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' enb_sample(D, U, Theta, t, prop, cost, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun,
#'            model = "s(theta_A)")
#' U_enbppi <- function(d, Theta_int, Theta_rem, t_1, t_2)
#'   sum(1.05^(1-(t_1:t_2)))*((d == 1)*Theta_int + (d == 2)*Theta_rem)
#' Theta_int <- matrix(Theta[,"theta_A"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_A"))
#' Theta_rem <- matrix(Theta[,"theta_B"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_B"))
#' out <- enb_partial_perfect(D, U_enbppi, Theta_int, Theta_rem, t, prop, cost, method = "NP",
#'                            model = "s(theta_A)")
#' enb_sample(D, U, Theta, t, prop, cost, method = "MM", samp_fun = samp_fun, post_fun = post_fun,
#'            INB_partial = out$INB_partial)
#'
#' # three parameters (two parameters of interest), three decision options
#' D <- 3
#' U <- function(d, Theta, t_1, t_2) sum(1.05^(1-(t_1:t_2)))*Theta[,d]
#' N <- 10000
#' Theta <- matrix(c(rbeta(N, 2, 3), rbeta(N, 2, 3), rbeta(N, 2, 3)),
#'                 nrow = N, ncol = 3, dimnames = list(NULL, c("theta_A", "theta_B", "theta_C")))
#' t <- c(C = 0, A = 1, H = 15)
#' prop <- rep(1/D, D)
#' cost <- 0
#' samp_fun <- function(Theta) apply(Theta[,c("theta_A", "theta_B")], 2,
#'                                   function(theta) rbinom(length(theta), size = 10, prob = theta))
#' post_fun <- function(J, x) matrix(c(rbeta(J, 2 + x["theta_A"], 3 + 10 - x["theta_A"]),
#'                                     rbeta(J, 2 + x["theta_B"], 3 + 10 - x["theta_B"]),
#'                                     rbeta(J, 2, 3)),
#'                                   nrow = J, ncol = 3,
#'                                   dimnames = list(NULL, c("theta_A", "theta_B", "theta_C")))
#' stat_fun <- function(x) x/10
#' enb_sample(D, U, Theta, t, prop, cost, method = "MC", samp_fun = samp_fun, post_fun = post_fun)
#' enb_sample(D, U, Theta, t, prop, cost, method = "NP", samp_fun = samp_fun, stat_fun = stat_fun,
#'            model = "te(theta_A, theta_B)")
#' U_enbppi <- function(d, Theta_int, Theta_rem, t_1, t_2)
#'   sum(1.05^(1-(t_1:t_2)))*((d == 1)*Theta_int[,"theta_A"] +
#'                              (d == 2)*Theta_int[,"theta_B"] +
#'                              (d == 3)*Theta_rem)
#' Theta_int <- Theta[,c("theta_A", "theta_B")]
#' Theta_rem <- matrix(Theta[,"theta_C"], nrow = N, ncol = 1, dimnames = list(NULL, "theta_C"))
#' cond_fun <- function(J, Theta_int) rbeta(J, 2, 3)
#' out <- enb_partial_perfect(D, U_enbppi, Theta_int, Theta_rem, t, prop, cost, method = "NP",
#'                            cond_fun = cond_fun, model = "te(theta_A, theta_B)")
#' enb_sample(D, U, Theta, t, prop, cost, method = "MM", samp_fun = samp_fun,
#'            post_fun = post_fun, INB_partial = out$INB_partial)
#' @rdname enb_sample
#' @export
enb_sample <- function(D, U, Theta, t, prop, cost, method = "NP", J = 10000, K = 10000, samp_fun = NULL,
                       post_fun = NULL, stat_fun = NULL, model = NULL, INB_partial = NULL, Q = 50){

  if(!(method %in% c("MC", "NP", "MM"))) stop("Method must be specified as MC, NP or MM")

  ## first compute the expected value of choosing now

  NB_now <- sapply(1:D, function(d) U(d, Theta, t["C"] + 1, t["H"]))
  INB_now <- NB_now - NB_now[,1]
  value_now <- max(colMeans(INB_now))

  ## second compute the expected value during the trial

  if(sum(prop) != 1) stop("prop must sum to one")
  NB_during <- sapply(1:D, function(d) U(d, Theta, t["C"] + 1, t["A"]))
  value_during <- mean(NB_during%*%prop - NB_during[,1])

  ## third compute the expected value of choosing after the trial

  N <- nrow(Theta)
  if(method == "MC"){
    if(N < K) stop("The number of parameter draws must be greater than or equal to K")
    Theta_redraw <- as.matrix(Theta[sample.int(N, size = K),])
    samp_out <- samp_fun(Theta_redraw)
    SI <- sapply(1:K, function(k){
      Theta_tmp <- post_fun(J, samp_out[k,])
      NB_tmp <- sapply(1:D, function(d) U(d, Theta_tmp, t["A"] + 1, t["H"]))
      INB_tmp <- NB_tmp - NB_tmp[,1]
      max(colMeans(INB_tmp))
    })
    value_after <- mean(SI)
  } else if(method == "NP"){
    NB <- sapply(1:D, function(d) U(d, Theta, t["A"] + 1, t["H"]))
    INB <- NB - NB[,1]
    samp_out <- samp_fun(Theta)
    summ_stats <- t(matrix(apply(samp_out, 1, stat_fun), ncol = N))
    colnames(summ_stats) <- colnames(samp_out)
    g_hat <- matrix(data = NA, nrow = N, ncol = D)
    g_hat[,1] <- 0
    RhpcBLASctl::blas_set_num_threads(1)
    for(d in 2:D) g_hat[,d] <- gam(update(formula(INB[, d] ~ .), formula(paste(".~", model))), data = as.data.frame(summ_stats))$fitted
    value_after <- mean(apply(g_hat, 1, max))
  } else if(method == "MM"){
    NB <- sapply(1:D, function(d) U(d, Theta, t["A"] + 1, t["H"]))
    INB <- NB - NB[,1]
    Theta_redraw <- gen.quantiles(parameter = colnames(Theta), param.mat = Theta, Q = Q)
    samp_out <- samp_fun(as.matrix(Theta_redraw))
    var_est <- lapply(1:Q, function(q){
      Theta_tmp <- post_fun(N, samp_out[q,])
      NB_tmp <- sapply(1:D, function(d) U(d, Theta_tmp, t["A"] + 1, t["H"]))
      INB_tmp <- NB_tmp - NB_tmp[,1]
      var(INB_tmp[,-1])
    })
    prior_var <- var(as.matrix(INB[,-1]))
    mu_mn <- colMeans(as.matrix(INB[,-1]))
    mu_var <- prior_var - Reduce("+", var_est)/Q
    if(D <= 2){
      INB_rescaled <- as.matrix((INB_partial[,-1] - mu_mn) * 1/sd(INB_partial[,-1]) * as.numeric(sqrt(mu_var)) + mu_mn)
    } else {
      mu_var_eigen <- eigen(mu_var)
      mu_var_sqrt <- mu_var_eigen$vectors %*% diag(sqrt(mu_var_eigen$values)) %*% t(mu_var_eigen$vectors)
      prior_var_eigen <- eigen(prior_var)
      prior_var_sqrt_inv <- chol2inv(chol(prior_var_eigen$vectors %*% diag(sqrt(prior_var_eigen$values)) %*% t(prior_var_eigen$vectors)))

      INB_rescaled <- t(t(t(t(INB_partial[,-1]) - mu_mn) %*% prior_var_sqrt_inv %*% mu_var_sqrt) + mu_mn)
    }
    value_after <- mean(apply(INB_rescaled, 1, function(x) max(0, x)))
  }

  ## finally compute the expected net benefit of collecting sample information

  ENB_SAMPLE <- (value_during + value_after - cost) - value_now

  return(ENB_SAMPLE)
}